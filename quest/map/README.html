TODO:
mapAddon
Attack

####################################
MAPS EVENTS:

By default, a map is just a plain image.
To bring life to the map, you will need to add an addon to it that will tell the engine what monsters/npc/lever to spawn.

When creating a quest, you might also want to modify a pre-existing map. 
To do that, you will create a new addon to pre-existing maps to modify them to your needs.

Always use the rc_sdk/map/creation/codeGenerator.html to get the addon template.

There are 3 different attributes for each addon: spot, load, loop.

ADVANCED: 
By default the name of the addon is your quest id.
There's a 4th attribute .variable that can contain any type of variable. Access it via this.variable in load or loop functions. 

####
.spot: Object
	List of position in the map.
	Spots should be generated automatically via Tiled by adding letters from the Tileset 9 on the map on the ZONE layer.	Check /map/creation for more info.
	
	spot will be the first parameter in the functions load and loop.
	A specific spot can be accessed via the "spot.[letter]".
	Ex: spot.a 	will contain the x, y and mapId of the letter 'a' in the tile project. (Note: spot['a'] is the EXACT same thing than spot.a)

####
.load: Function(spot)		
	This function will be called once when initializing the map.
	Used for: Create enemy, create npc, create switch, create block etc...

####
.loop Function(spot)	
	This function will be called every frame (25 times per second).
	Used for: Test collision that will trigger another event. Ex: Teleport Zone. 
	
######################
LOAD:

Create Actor: (Enemy, Npc, Switch, Block, Cuttable Trees, Doors)
	All actors have a specific template. When creating an actor, you need to specify the template to use.
	Each template has an id with 2 components: category and variant.
	
	In order to create an enemy that has different attribute than the template, you need to specify the differences in the "extra" parameter.
	
	## Basic Examples ##
	s.actor(
		spot.c,			//spot:		enemy will spawn where the 'c' is on the tile project
		"goblin",		//category:	template used will be the goblin-red one (assuming the template exists)
		"red",			//variant: 	
		{},				//extra:	enemy exactly the same than the template since extra is empty
	);
	
	
	s.actor(		
		spot.c,				
		"goblin",		
		"red",
		{				//same enemy than above EXCEPT that this only has 9001 hp and moves slowly
			hp:9001,
			maxSpd:0.001,
		},					
	);
	
	
	In other to create a enemy that can respawn, the enemy needs to be in a group. Note: The group be be only 1 enemy.
	
	s.actorGroup(			//create a group of monsters that respawns
		{
			'xym':spot.a,	
			'respawn':100			
		},
		[
			{							//first enemy type of the subgroup
				'amount':3,					//amount
				"category":"troll",			//enemy category
				"variant":"ice",			//enemy variant
				"extra":{},					//extra is applied to every monster of this type in that subgroup
			},
			{							//second enemy type of the subgroup
				'amount':2,
				"category":"troll",
				"variant":"fire",
				"extra":{},	
			},		
		]
	);
	s.actorGroup(
		spot.e1,		//spot
		25*15,			//amount of frames before enemy group respawns (timer starts when last member is dead)
		[	
			[
				"orc",		//enemy category
				"melee",	//enemy variant
				2,			//amount
				{}			//extra is applied to every monster of this type in that subgroup
			],
			["orc","range",1,{deathFunc:q.event.killOrc}],		//other subgroup
			["orc","magic",5,{deathFunc:q.event.killOrc}],		//other subgroup
		]	
	);	
	
	
	#####################
	## Extra Parameter ##
	The extra parameter is used to allow the actors to do various stuff:
			
	####
	Dialogue: 
		Can right-click to talk to. used to trigger dialogues. 
		PARAM: key
		---------------------
		dialogue:q.event.myDialogue,
				
		//An example of what the quest event could be:
		q.event.myDialogue = function(key){
			if(s.get(key,'haveKilledDragon') === true){
				s.dialogue(key,'Jenny','intro','intro2');
			} else {
				s.dialogue(key,'Jenny','intro','intro0');
			}		
		};
		
		
	####
	Event on Death (For Each killer):
		Call quest event for each player who dealt 1+ dmg to this monster when this monster dies
		PARAM: key | act: enemy who died object
		---------------------
		deathFunc:q.event.dragonKilled,
		
		//An example of what the quest event could be:
		q.event.dragonKilled = function(key,act){
			s.set(key,'haveKilledDragon',true);
		};		
		
	####
	Switch
		Call quest event when player activate/desactivate this actor. 
		It starts in the "off" position. (Player activating it for first time will trigger "on" event)
		RECOMMENDED: Use the enemy from category 'switch'	(Ex: switch,box)
		
		PARAM: key | act: enemy being clicked object | map: map object
		---------------------
		switch:{		
			on:q.event.unlockDoor,
			off:q.event.lockDoor,
		}
		//not specifying the "off" option means the switch can only be activated once
		
		
		//An example of what the quest event could be:
		q.event.unlockDoor = function(key,act,map){
			s.set(key,'doorLocked',false);
		};	
		
		
		
	####
	Loot
		an enemy that acts as a chest/loot. can only be looted once per player. 	
		RECOMMENDED: Use the enemy from category 'loot' (Ex: loot,chest)
		
		PARAM: key
		RETURN: Boolean. Your quest event must return true if it was succesful, false otherwise. (Ex: if enough inventory space)
		---------------------
		chest:q.event.giveMoney,
		
		//An example of what the quest event could be:
		q.event.giveMoney = function(key){
			if(s.testItem(key,'gold',1000) === true){	//if space for 1k gold
				s.addItem(key,'gold',1000);	
				return true;
			} else {
				return false;
			}
		} 
		
		ADVANCED:	This does the same thing.
		q.event.giveMoney = function(key){
			return s.testItem(key,'gold',1000,true);
		}
	
	####
	ViewedIf
		condition to see the enemy. also affect collision (ex: if enemy is a block)
		
		PARAM: key | eid : enemy being seen id string
		RETURN: Boolean. Your quest event must return true if the player can see the npc, false otherwise.
		---------------------
		viewedIf:q.event.canSeeRock,
		
		//An example of what the quest event could be:
		q.event.canSeeRock = function(key,eid){
			if(s.get(key,'brokeRock') === true){
				return false;
			} else {
				return true;
			}
		} 
	
	
	

	####
	Combat?
		is the enemy in combat? being in combat means that he can perform attacks, be attacked and if its a monster, it can target/follow a player
		
		combat:false,
	
	####
	Move?
		can the enemy move?
		
		move:false,
	
		
	ADVANCED: For the full list of actor extra (not-related to quest), check /server/Actor.init.js
	
	
	####################
	Create a block line:
		Automatically create multiple actors (blocks) that like block the player. Useful for boss fight.
	
	s.block(
		spot.b1,				//needs to be a zone (not a single point) needs to be 1xn or nx1
		q.event.myCondition,	//viewedIf	(put null if no condition)
		'spike',				//sprite name (default is 'spike')
		{},						//extra
	)
	
	


###################		
LOOP COMMON FUNCTIONS


	
####
Call Quest Event if player is in a zone:
	If a player is in that zone, call a quest event.
	
	PARAM: 	0: spot zone. (should have been made with multiple letters in Tiled)
			1: quest event to call
	
	ex:
	collision(spot.a,q.event.spawnEnemy);
	
	//An example of what the quest event could be:
	q.event.damagePlayer = function(key){
		s.getAct(key).hp -= 100;
	} 
	
	
	
	
Everything in the loop function will be called every frame. 
However, for performance reasons, it is advised to use Loop.interval (not needed for teleZone and collision though)

	s.interval(time)   return true every [time] frames.
	
Ex:
if(s.interval(100)){		//do something... every 100 frames (every 4 seconds)
	something...
}
	
	
	
	
	
	
	
	
	
	
	
	
### ADVANCED ###

Addon additional attributes:
	####
	.path: Object
		List of paths in the map.
		Paths should be generated automatically via Tiled by adding numbers from the Tileset 9 on the map on the PATH layer.	Check /map/creation for more info.
		Paths are rarely used....	NO DOCUMENTATION YET.
		
	####
	.variable: Object
		Contains custom variables. Those can be any type. Each map has its own copy of variables.
		Variables are rarely used....	NO DOCUMENTATION YET.	

###########################

Advanced Extra attributes:		
	###
	Function on Click
		set a function to call when player click on the enemy. onclick info will be added to optionList automatically
		do NOT use right click (reserved for optionList)
		
		onclick:{
			shiftLeft:{
				func:q.event.myEvent,
				param:[],		//unsure if param is needed.... put it incase XD
			},
			left:same,
			shiftRight:same,			
		}
		
	####
	Function on Death (Called once)
		Called once whe monsters dies (unlike deathFunc that calls it for each player)		
		PARAM: killers: array of player objects | mort: enemy who died object | map: mapId
		
		deathFuncArray:function(killers,mort,map){},			
		
	####
	Delete On Death:
		delete this enemy when he dies. 
		
		deleteOnceDead:true,
		
	####
	Ability Cast on Death:
		List of abilities the enemy will trigger when dying (their index in the .ability attribute of the enemy - check Db.enemy to know what they are).
		
		deathAbility:[0, 2],
		
	####
	Condition to damage player
		change who can be damaged by the attacks made this actor. check Combat.damageIf
		RETURN: Boolean
		
		damageIf:function(defObj,atkObj){
			return true if atkObj can damage defObj
		},
		damageIf:'enemy',		//can also be string and will refer to Combat.damageIf.list
	
	####
	Condition be damaged
		test if defObj can be a target of the enemy.
		RETURN: Boolean
		
		damagedIf:function(defObj,atkObj){
			return true if atkObj can target defObj
		},	
		damagedIf:'true',		//can also be string and will refer to Combat.damageIf.list
	####
	Condition to target player
		test if defObj can be a target of the enemy.
		RETURN: Boolean
		
		targetIf:function(defObj,atkObj){
			return true if atkObj can target defObj
		},	
		
	
